# Antopic Tarafından Geliştirilen Açık Kaynaklı MCP Protokolünün Mimari Yapısı, İşlevselliği ve Güvenlik Açısından Değerlendirilmesi

## Giriş

**Model Context Protocol (MCP)**, Anthropic şirketi tarafından açık kaynak olarak geliştirilmiş bir protokoldür ve büyük dil modellerini (Large Language Models - *LLM*) harici veri kaynakları ve araçlarla entegre etmeyi amaçlar. Bir bakıma, yapay zeka uygulamaları için **USB-C standardı** gibi çalışarak LLM tabanlı uygulamaların dış sistemlerle bağlanması için standart bir yol sağlar. Bu araştırmanın amacı, MCP protokolünün teknik mimarisi ile ağ içi işleyiş modelini inceleyerek yazılım geliştirme süreçlerindeki kullanım biçimlerini ortaya koymak ve protokolün siber güvenlik bağlamında oluşturabileceği potansiyel riskleri değerlendirmektir. Bu doğrultuda, MCP’nin temel hedefleri ve kullanım alanları, mimari yapısı ve veri iletim mekanizması, hangi katmanda çalıştığı ve bunun sağladığı avantajlar ile protokolün açık kaynak olmasının güvenliğe etkileri ele alınacaktır. Ayrıca MCP’ye yönelik olası saldırı türleri (örn. Ortadaki Adam, Replay, Enjeksiyon) incelenerek Anthropic’in (Antopic) uyguladığı güvenlik önlemlerinin yeterliliği değerlendirilecek ve **MCP’nin güvenli bir şekilde uygulanabilmesi için öneriler** sunulacaktır.

<img width="1207" height="799" alt="resim" src="https://github.com/user-attachments/assets/bdf1510b-66f6-427b-9562-f8653e73d66e" />


## MCP Protokolünün Amacı ve Kullanım Alanları

MCP protokolünün temel amacı, LLM tabanlı yapay zeka uygulamaları ile harici araçlar, veri kaynakları ve hizmetler arasında **standart bir bağlamsal iletişim** sağlamaktır. Bu sayede bir yapay zeka modeli, kısıtlı kendi bilgi havuzunun ötesine geçerek güncel verilere erişebilir, çeşitli eylemleri tetikleyebilir veya harici uygulamalardan sonuçlar alabilir. Örneğin GitHub Copilot gibi bir kod yardımı aracı, MCP üzerinden GitHub’ın kendi hizmetleriyle veya üçüncü parti araçlarla entegre olarak daha ileri işlemler yapabilmektedir. Anthropic’in Claude modeli gibi bir LLM de MCP sayesinde harici “araçlar” kullanarak ide ortamında dosya sistemine erişmek veya bir hata izleme (sentry) platformundan veri çekmek gibi eylemlere girişebilir.

<img width="960" height="540" alt="resim" src="https://github.com/user-attachments/assets/ac7686e8-9c5d-4a30-be7c-9fa1f7328325" />

MCP protokolü, geniş bir yelpazedeki kullanım senaryolarını mümkün kılarak yapay zekâ uygulamalarının yeteneklerini artırır. Aşağıda MCP’nin sağlayabildiği bazı olanaklar listelenmiştir:

* **Kişisel Asistan Entegrasyonu:** Yapay zekâ “agent”ları kullanıcıların Google Takvimi veya Notion hesaplarına bağlanarak daha kişiselleştirilmiş asistanlar gibi davranabilir. Örneğin, takvimden randevuları okuma veya yeni notlar oluşturma gibi işlemleri gerçekleştirebilir.
* **Tasarım'dan Koda Otomasyon:** Claude Code gibi bir AI aracı, MCP aracılığıyla bir Figma tasarımını analiz ederek komple bir web uygulamasını otomatik olarak oluşturabilir. Bu, tasarım ve geliştirme süreçlerini hızlandıran bir entegrasyon örneğidir.
* **Kurumsal Veri Erişimi:** Kurum içindeki bir sohbet botu, MCP üzerinden organizasyonun farklı veritabanlarına aynı anda bağlanabilir ve kullanıcının doğal dilde sorduğu sorulara dayanarak gerçek zamanlı veri analizi yapabilir. Bu sayede tek bir arayüz üzerinden birden çok veri kaynağı taranabilir.
* **Fiziksel Cihaz Kontrolü:** Bir yapay zekâ modeli, MCP ile Blender gibi bir 3D tasarım aracına ve bir 3B yazıcıya bağlanarak, doğal dil komutlarla 3D model tasarlayıp bunu yazıcıdan basabilir.

Yukarıdaki örnekler MCP’nin **genel amaçlı bir entegrasyon altyapısı** olarak ne denli esnek kullanılabildiğini göstermektedir. Son kullanıcı açısından bu, yapay zekâ destekli uygulamaların kendi verilerine erişip gerekirse kullanıcı adına eyleme geçebilen daha yetenekli asistanlar haline gelmesi demektir. Geliştiriciler için ise MCP, bir yapay zekâ uygulamasına entegrasyon noktaları eklerken zaman kazandıran ve karmaşıklığı azaltan standart bir arayüz sunmaktadır.

## MCP'nin Mimari Yapısı ve Veri İletim Mekanizması


<img width="840" height="328" alt="resim" src="https://github.com/user-attachments/assets/ba600697-942e-426f-ad1c-839875ef9772" />


MCP istemci ve sunucularının LLM ile etkileşimini gösteren örnek bir akış diagramı. Kullanıcı isteği, istemci tarafından LLM'ye iletilir; LLM uygun aracı seçerek sunucuya çağrı yapar ve sonuç yine LLM üzerinden kullanıcıya döner.*

MCP protokolü, istemci-sunucu modeline dayalı **iki katmanlı bir mimariye** sahiptir. Katmanlardan ilki **veri katmanı** (*data layer*) olup istemci ile sunucu arasındaki mesajların yapısını ve anlamını tanımlayan bir JSON-RPC 2.0 tabanlı protokoldür. Bu katmanda bağlantının başlatılması, sürdürülmesi ve sonlandırılması gibi yaşam döngüsü yönetimi; sunucunun sağlayabileceği *araçlar* (tools) ve *kaynaklar* (resources) gibi işlevler; istemcinin LLM'den çıktı üretmesini talep etme veya kullanıcı girdisi isteme gibi kabiliyetler ve uyarı/iletişim amaçlı *bildirimler* yer alır. İkinci katman olan **taşıma katmanı** (*transport layer*), veri alışverişinin hangi iletişim kanalları üzerinden ve nasıl yapılacağını tanımlar; bağlantı kurulumu, mesaj çerçeveleri ve taraflar arasında kimlik doğrulama bu katmanda ele alınır. MCP’nin tasarımında mevcut iki taşıma yöntemi şunlardır:

* **STDIO Taşıması:** İstemci ve sunucunun aynı makinede yerel olarak çalıştığı durumlarda standart girdi/çıktı akışı üzerinden iletişim kurulabilir. Bu yöntem, herhangi bir ağ protokolü kullanmadığı için ek gecikme veya ağ trafiği oluşturmaz; dolayısıyla maksimum performans sağlar ve özellikle bir IDE içinde çalıştırılan yerel araçlar için idealdir.
* **Akış Destekli HTTP Taşıması:** İstemci ile sunucu arasında HTTP üzerinden iletişim kurulmasını sağlar. İstemci, sunucuya JSON tabanlı isteklerini HTTP POST ile gönderirken; sunucu gerektiğinde **Server-Sent Events (SSE)** kullanarak istemciye akan (*streaming*) yanıtlar iletebilir. Bu yöntem uzaktaki (bulut veya internet üzerindeki) MCP sunucularına bağlanmak için kullanılır ve standart HTTP kimlik doğrulama mekanizmalarını destekler (taşıyıcı jetonlar, API anahtarları veya özel başlıklar gibi). Uzaktan iletişimde verinin gizliliği ve bütünlüğü için MCP üzerinden **HTTPS (TLS şifrelemesi)** kullanılması önerilmektedir.

Yukarıdaki mimari sayesinde MCP, birden fazla sunucuya aynı anda bağlanabilen esnek bir istemci-çoklu sunucu topolojisi oluşturur. Bu yapıda **MCP İstemcisi**, LLM barındıran uygulamanın içinde çalışarak her bir MCP sunucusuyla birebir bağlantı kuran bileşendir. **MCP Sunucusu** ise harici bağlam bilgisini sağlayan bağımsız bir süreçtir; dosya sistemi, veritabanı, harici API gibi kaynaklara erişebilir ve bunları istemciye bir “araç” arayüzüyle sunar. Örneğin Visual Studio Code editörü bir MCP **host** uygulaması olarak düşünülebilir; VS Code, Sentry hata izleme sistemi için bir MCP sunucusuna bağlandığında (uzak bir sunucu), aynı anda yerel dosya sistemi erişimi sunan başka bir MCP sunucusuna da bağlanabilir. Bu durumda VS Code içinde her sunucu bağlantısı için ayrı bir MCP istemci nesnesi çalışır ve her biri ilgili sunucusundan veri çeker.

<img width="836" height="512" alt="resim" src="https://github.com/user-attachments/assets/d0cdaa6e-aff0-4d03-ab74-bbd6107c5ff1" />

**Veri iletim mekanizması**, istemci, sunucu ve LLM arasındaki etkileşimle gerçekleşir. Bu akışı adım adım incelemek gerekirse:

1. **Kullanıcı isteği:** Son kullanıcı, MCP entegrasyonuna sahip AI uygulamasından (örneğin bir sohbet arayüzü veya IDE) bir talepte bulunur. Bu talep doğal dilde bir komut, soru veya görev tanımı olabilir ve öncelikle **MCP istemcisi** tarafından ele alınır.
2. **LLM ile planlama:** MCP istemcisi, bağlı olduğu MCP sunucularının hangi araçları sağladığı bilgisini elinde tutar. Kullanıcının isteğini alır almaz istemci, sunuculardan aldığı bu yetenek bilgilerini de **LLM’ye aktarır**. Başka bir deyişle, LLM’ye *“şu şu araçlar mevcut”* bilgisini vererek kullanıcı talebini çözümler. LLM, verilen görevi yerine getirmek için hangi araca ihtiyaç olduğunu ve bu araca hangi parametrelerle çağrı yapılacağını kararlaştırır ve istemciye bir yanıt üretir.
3. **Sunucuya istek:** LLM’nin yanıtına göre MCP istemcisi, ilgili aracı barındıran MCP **sunucusuna** bir istek gönderir. Bu istek, belirli bir aracı çalıştırma komutunu ve gerekli parametreleri içerir. İletişim, yerel sunucu ise STDIO üzerinden, uzak sunucu ise HTTP istekleri ile gerçekleşir.
4. **Sunucu işlemi ve yanıt:** MCP sunucusu, kendisine iletilen komutu gerçekleştirir. Örneğin bir dosya okuma aracına parametre olarak bir dosya yolu verildiyse, sunucu dosyayı okuyup içeriğini döndürür. Sunucu, işlemin sonucunu (ya da hata çıktıysa hata bilgisini) MCP istemcisine geri gönderir.
5. **LLM'nin sonuç üretmesi:** MCP istemcisi sunucudan aldığı ham sonucu tekrar LLM’ye iletir (veya LLM zaten önceki adımda bu sonucu bekliyor olabilir). LLM, sunucudan gelen veriyi kullanarak kullanıcıya verilecek nihai cevabı oluşturur. Örneğin, dosya içeriği istenmişse bunu kullanıcıya uygun biçimde sunan bir metin cevabı üretir.
6. **Kullanıcıya sunum:** Son olarak MCP istemcisi, LLM’nin ürettiği cevabı alır ve uygulama arayüzü üzerinden kullanıcıya gösterir. Kullanıcı, talebinin sonucunu insan tarafından yazılmışçasına doğal bir dilde almış olur.

Bu işlem döngüsü, MCP sayesinde LLM tabanlı bir sistemin **etkin bir araç kullanıcısına** dönüşmesini sağlamaktadır. Önemle vurgulanmalıdır ki MCP, LLM ile araçlar arasında doğrudan bir bağlantı kurmaz; bunun yerine istemci ve sunucu aracılığıyla kontrollü bir entegrasyon gerçekleştirir. İstemci tarafı LLM ile konuşmaktan sorumlu iken, sunucu tarafı gerçek dünya araçlarını çalıştırma görevini üstlenir. Bu ayrım, güvenlik ve kontrol açısından da önemlidir çünkü LLM’nin her şeye doğrudan erişimi olmaz; sadece istemcinin sunduğu arayüz dahilinde eylem yapabilir.

## Protokolün Katman Seviyesi ve Avantajları

MCP protokolü **uygulama katmanında** çalışan bir protokoldür. Yani OSI modeline göre bakıldığında, TCP/IP gibi taşıma katmanı protokollerinin üzerinde konumlanır ve uygulamalar arası veri alışverişinin anlamını tanımlar. Bu yüksek seviyeli konum, MCP’ye önemli avantajlar kazandırmaktadır. Öncelikle, uygulama katmanı protokolü olduğu için MCP mesajları **insan tarafından okunabilir JSON** formatında tanımlanmıştır ve bu sayede dil agnostik bir şekilde birden fazla programlama dilinde kolaylıkla uygulanabilir (nitekim halihazırda MCP için Python, TypeScript, Java, C#, Go, Rust gibi farklı dillerde SDK’lar mevcuttur). Protokol mesajlarının JSON-RPC standardını kullanması, yapılandırılmış bir iletişim sağlayarak hem istemci hem sunucu tarafında uygulanmasını ve hata ayıklamasını kolaylaştırır.

MCP’nin taşıma bağımsız bir üst düzey protokol olarak tasarlanmış olması, **esneklik** ve **uyumluluk** avantajı sağlar. Protokol, altında yatan taşıma katmanını soyutlayabildiği için aynı veri yapısını ister yerel ister uzak senaryolarda iletebilir. Örneğin, bir geliştirici MCP sunucusunu başlangıçta yerel STDIO modunda çalıştırıp test edebilir; daha sonra minimal değişiklikle aynı sunucuyu uzak bir HTTP servis olarak dağıtabilir. Bu sayede protokol, gelişen ihtiyaçlara göre ölçeklenebilir bir yapı sunar. Ayrıca MCP, doğrudan IP seviyesinde yeni bir protokol icat etmeyip HTTP gibi yaygın bir uygulama protokolünü opsiyon olarak kullandığı için mevcut altyapılarla **uyumludur** – güvenlik duvarları, yük dengeleyiciler veya HTTPS şifrelemesi gibi halihazırda oturmuş mekanizmaları tekrar keşfetmeye gerek kalmadan kullanabilir.

Taşıma katmanının soyutlanmasıyla gelen bir diğer avantaj, **güvenli iletişim ve kimlik doğrulama konusunda standartların yeniden kullanılmasıdır**. MCP, uzak sunucularla haberleşirken HTTPS üzerinden çalışarak TLS şifrelemesini devreye sokabilmekte ve HTTP’nin oturmuş kimlik doğrulama yöntemlerini (OAuth erişim tokenları, API anahtarları, vb.) aynen kullanabilmektedir. Bu, protokolün güvenlik konusunda güvenilir ve test edilmiş yöntemlerden faydalanmasını sağlar. Örneğin, Anthropic varsayılan olarak MCP yetkilendirmesi için OAuth 2.0 tabanlı bir token mekanizmasını öngörmüştür. Son kullanıcı açısından, MCP trafikleri tıpkı bir web trafiği gibi güvenli kanaldan akabildiği için ağ dinlemesi veya benzeri riskler azaltılmaktadır. Öte yandan yerel taşıma seçeneği (STDIO), ağ üzerinden veri geçirmediği için özellikle tek makine üzerinde çalışan senaryolarda **azami performans ve güvenlik** (dış saldırı yüzeyinin olmaması nedeniyle) sunar.

Özetle, MCP’nin uygulama katmanında konumlanması ve altındaki taşıma katmanını esnek tutması protokolü geniş bir kullanım yelpazesinde pratik hale getirmektedir. Bu sayede hem *platform bağımsızlığı* hem de *güvenlik ve performans* açısından geliştiricilere önemli kolaylıklar sağlar.

## MCP’nin Açık Kaynak Yapısının Güvenliğe Etkileri

MCP protokolünün **açık kaynak** olması, güvenlik açısından çift yönlü etkilere sahiptir. Olumlu tarafta, protokolün kaynak kodu ve spesifikasyonlarının açık olması, geniş bir topluluk tarafından incelenebilmesini ve katkı yapılabilmesini mümkün kılar. Nitekim MCP hızla popülerlik kazanırken, çeşitli güvenlik araştırmacıları ve şirketler de protokolü mercek altına almıştır. Bu kolektif inceleme sayesinde protokoldeki potansiyel zayıflıklar erken aşamada tespit edilip düzeltilebilmektedir. Topluluk üyeleri mevcut yetkilendirme mekanizmasının kurumsal uygulamalarla çelişen noktalarını fark etmiş ve yetkilendirme spesifikasyonunun iyileştirilmesi için girişimde bulunmuştur. Bu sayede, protokol geliştikçe güvenlik boyutunda da güncel en iyi uygulamalarla uyumlu hale gelmesi sağlanmaktadır.

Açık kaynağın bir diğer avantajı, *güvenlikte şeffaflık* sağlamasıdır. MCP ekosistemindeki istemci ve sunucu uygulamaları açık kaynak kodlu olduğu için, geliştiriciler veya kurumlar bu kodları inceleyerek içlerinde zararlı bir işlev olup olmadığını denetleyebilir. Kapalı kutu bir yazılıma kıyasla, açık kodlu bir MCP sunucusunun ne yaptığı görülebilir olduğu için sürpriz istenmeyen davranışlar riski teorik olarak daha düşüktür. Dahası, ekosistemdeki popüler MCP bileşenleri genellikle dijital imza ile yayınlanmakta veya bütünlük kontrolüne tabi tutulmaktadır; bu da koda dışarıdan zararlı bir müdahale yapılmadığını doğrulamayı mümkün kılar. Geliştiricilerin de kendi yayınladıkları MCP sunucularını imzalamaları ve kullanıcıların bu imzaları doğrulamaları tavsiye edilmektedir.

Öte yandan, açık kaynak olmanın getirdiği bazı **güvenlik riskleri** de vardır. Her şeyden önce, MCP protokolü tamamen açık bir ekosistem olduğundan, kötü niyetli aktörler de protokolü kullanarak zararlı MCP sunucuları geliştirebilir ve bunları topluluk içinde paylaşabilir. Örneğin, bir saldırgan ilk bakışta yararlı görünen bir MCP sunucusu (belki bir hava durumu aracı veya takvim aracı) yayınlayıp kullanıcıları bunu kurmaya ikna edebilir; ancak daha sonra bir güncelleme ile bu sunucuya gizlice hassas bilgileri toplayan veya yetkisiz komutlar çalıştıran işlevler ekleyebilir. Bu tür **“araç enjeksiyonu”** diyebileceğimiz senaryolarda, açık kaynak kod başlangıçta temiz olsa bile ileride kasıtlı olarak suistimal edilebilir hale getirilebilir. Benzer şekilde, sunucunun tanıttığı araçların ismini ve tanımını yanıltıcı seçmek de mümkün olduğundan, kötü niyetli bir geliştirici masum görünen bir aracı aslında farklı ve tehlikeli işler yapmak için tasarlayabilir. Açık kaynak dünyasında kullanıcıların her buldukları projeye güvenmemeleri, özellikle de MCP gibi *kod çalıştırma yeteneği olan* sunucular söz konusuysa, son derece kritiktir.

Açık kaynağın bir diğer zorluğu da **tedarik zinciri güvenliği** ile ilgilidir. MCP istemci ve sunucuları da sonuçta yazılım bileşenleridir ve paket yönetim sistemleri üzerinden dağıtılır. Saldırganlar popüler MCP paketlerinin isimlerini taklit eden (typosquatting) zararlı paketler yayınlayabilir veya geliştiricilerin hesaplarını ele geçirip zararlı güncellemeler çıkarabilir. Bu risk, genel olarak tüm açık kaynak projelerinde mevcuttur ve MCP de bir istisna değildir. Nitekim, MCP bileşenlerinin güvenliği için tavsiye edilen uygulamalar arasında *Statik Kod Analizi (SAST)* ve *Yazılım Bileşeni Analizi (SCA)* araçlarının kullanılması, bağımlılıkların bilinen zafiyetlere karşı taranması gibi süreçler sayılmaktadır. Proje geliştirme süreçlerinde bu tür güvenlik denetimlerinin uygulanması, açık kaynak olmanın getirdiği riskleri azaltmaya yardımcı olur.

Sonuç olarak, MCP’nin açık kaynak yapısı güvenlikte hem bir **imkan** hem de bir **sorumluluk** doğurmaktadır. Doğru yönetildiğinde, geniş bir katılımcı kitlesinin katkısıyla daha güvenli bir protokol gelişimi mümkün olmakta; ancak bu açıklık aynı zamanda suistimale açık bir ekosistem yarattığı için, kullanıcıların ve geliştiricilerin güvenlik farkındalığının yüksek olması gerekmektedir.

## Potansiyel Saldırı Senaryoları

MCP protokolü ve onu kullanan uygulamalar, tasarım itibariyle çeşitli saldırı türlerine maruz kalabilir. Bu bölümde, özellikle **Ortadaki Adam (Man-in-the-Middle)**, **Replay (Yeniden Oynatma)** ve **Enjeksiyon** saldırı vektörleri üzerinde durulacaktır:

* **Ortadaki Adam Saldırısı (MITM):** Bir MITM saldırısında, saldırgan istemci ile sunucu arasındaki trafiği gizlice dinleyip değiştirebilir. MCP, uzak sunucu bağlantılarında HTTP tabanlı iletişim kullandığı için, **şifrelenmemiş bir bağlantı (HTTP)** üzerinden iletişim kurulursa ciddi bir MITM riski oluşur. Örneğin, yerel ağda bir saldırgan MCP istemcisinin sunucuya giden trafiğini yakalayıp başka bir sunucuya yönlendirebilir veya içerik enjeksiyonu yapabilir. Bu nedenle MCP kullanımında **TLS şifrelemesi (HTTPS)** şarttır; aksi halde oturum açılış bilgilerinden, iletilen bağlam verisine kadar her şey üçüncü şahıslarca görülebilir veya değiştirilebilir. MITM sadece gizli dinleme değil, aynı zamanda istemci ile sunucu arasına girerek sahte yanıtlar verme veya istemciden gelen isteği bloklama gibi etkiler de yaratabilir. Uzak sunucularla iletişimde HTTPS kullanmak ve sunucu sertifikasını doğrulamak, bu tür saldırıların önlenmesinde temel önlemdir.

* **Replay Saldırıları:** Replay (yeniden oynatma) saldırısında, ağ trafiğini yakalayan bir saldırgan daha sonra bu trafiği tekrar göndererek sistemi kandırmaya çalışır. MCP protokolünde istemci-sunucu mesajları genellikle belirli bir isteğe yanıt ilişkisi içinde olduğundan ve protokol durumsal bir oturum yapısı barındırdığından, klasik anlamda replay yapmanın etkisi sınırlı olabilir. Ancak özellikle kimlik doğrulama veya yetki bilgilerinin tekrar kullanılması riski her zaman vardır. Örneğin bir saldırgan, bir MCP isteğini üzerindeki OAuth erişim jetonu ile birlikte ele geçirirse, bu isteği değiştirip yeniden göndermek suretiyle istenmeyen işlemler yaptırabilir. MCP spesifikasyonunda versiyon pazarlığı ve oturum başlatma mekanizmaları olsa da, **anti-replay için özel bir nonce veya zaman damgası kullandığına dair** açık bir bilgi olmayabilir. Dolayısıyla replay riskinin esasen **taşıma katmanının güvenliği** ile bertaraf edildiğini varsayabiliriz (örn. TLS içindeki oturum kimliği ve kısa ömürlü token kullanımı). Yine de, MCP sunucularının kritik işlemler için isteklerin tekilliğini kontrol etmesi veya aynı token’ın art arda kullanımını kısıtlaması gibi önlemler düşünülebilir. Sonuç itibariyle, replay saldırılarına karşı **en iyi savunma**, trafiğin şifrelenmesi ve geçerlilik süresi sınırlı, tek seferlik yetkilendirme jetonları kullanılmasıdır.

* **Enjeksiyon Saldırıları:** MCP ekosisteminde *enjeksiyon* kavramı birden fazla boyutta karşımıza çıkar:

  * **Komut Enjeksiyonu:** Birçok MCP sunucusu, alt seviyede kabuk komutları veya sistem çağrıları çalıştırarak görevlerini yerine getirir (özellikle yerel sunucular). Eğer sunucu, kullanıcıdan veya LLM’den gelen girdileri uygun şekilde filtrelemez ve doğrudan bir komut satırına aktarırsa, saldırganlar bu durumu **komut enjeksiyonu** için kullanabilir. Örneğin, bazı MCP sunucu kodlarında, kullanıcı bildirim başlığı oluşturulurken gelen değerin doğrudan `notify-send` komutuna parametre verildiği görülebilir; burada yeterli denetim olmadığından potansiyel bir komut enjeksiyonu açıklığı oluşabilir. Kötü niyetli bir aktör, özel hazırlanmış girdilerle bu açığı tetikleyerek sunucunun yetkileriyle rastgele komutlar çalıştırabilir. Bu tür vakalar, özellikle yerel MCP sunucularının kullanıcı hesabı haklarıyla çalıştığı senaryolarda **tam sistem tehlikeye atılması** ile sonuçlanabilir. Dolayısıyla MCP sunucusu geliştiricilerinin, çalıştırdıkları komutları ve bu komutlara verdikleri argümanları çok sıkı şekilde denetlemeleri, gerekirse girilen değerleri beyaz liste yöntemiyle filtrelemeleri kritiktir. Ayrıca, yerel sunucuların bir **sandbox (korunaklı ortam)** içinde, erişim izinleri kısıtlanmış şekilde çalıştırılması önerilmektedir.
  * **Prompt Enjeksiyonu:** Bu saldırı türü doğrudan protokolün teknik altyapısını değil, LLM’nin zafiyetini hedef alır ancak MCP bağlamında özel bir önem kazanır. MCP, LLM’nin dış araçları kullanmasına olanak sağladığı için, kötü niyetli bir yönlendirme (prompt) ile LLM’yi tehlikeli bir aracı çalıştırmaya ikna etmek mümkün hale gelebilir. Örneğin, bir saldırgan kullanıcıyı kandırarak MCP istemcisine girdiği komutun içine gizlenmiş zararlı bir talimat koydurabilir. LLM bu girdiyle çalışırken, görünürde masum görünen isteği gerçekleştirmenin yanında saldırganın arzusuyla ek bir işlem de başlatabilir (örneğin, “talep edilen yeni kullanıcı hesabını oluşturmanın” yanı sıra bir de saldırgan için yüksek yetkili bir hesap oluşturma). Bu tür prompt enjeksiyonları, özellikle LLM yanıtlarına koşulsuz güvenilip kullanıcı onayı aranmadan eyleme döküldüğünde ciddi hasarlara yol açabilir. Bu nedenle, MCP istemcileri kritik işlemleri gerçekleştirmeden önce mümkün olduğunca **kullanıcıdan onay almalıdır** veya LLM'nin yapabileceklerini kısıtlayacak politikalar uygulamalıdır.
  * **Araç (Tool) Enjeksiyonu:** Yukarıda açık kaynak riskleri kısmında değinilen senaryonun bir parçası olarak, MCP sunucularının tanıttığı araçlar suistimal edilebilir. Bu saldırı, bir bakıma *supply chain* sorunuyla birleşir; bir saldırgan, sağladığı aracın masum fonksiyonunu daha sonra güncelleyerek kullanıcıya zarar verecek hale getirebilir. Örneğin, başlangıçta sadece hava durumu bilgisini döndüren bir araç, ileride güncellemeyle kullanıcı verilerini çalan bir kod parçasına dönüştürülebilir. LLM, aracın açıklamasına güvenerek onu kullanacağı için, bu durumda saldırgan arka planda kötü faaliyetine devam ederken, kullanıcı ve istemci tarafı yalnızca aracın normal çıktısını görüp aldatılabilir. Bu nedenle, MCP istemcilerinin kurulu sunucuların kod veya davranış değişikliklerini izleyebilmesi, versiyon kilitleme (*pinning*) yaparak beklenmedik güncellemeleri engellemesi ve kullanıcıyı bilgilendirmesi önemli bir koruma yöntemidir.

Yukarıdaki saldırı türleri MCP protokolünün farklı bileşenlerini hedef almakla birlikte, ortak nokta olarak *MCP kullanımında güvenlik bilincinin önemini* ortaya koymaktadır. Gerek altyapısal (ör. MITM, replay) gerek uygulama seviyesinde (enjeksiyon) olsun, protokolü kullanırken uygun önlemler alınmadığı takdirde istenmeyen sonuçlarla karşılaşmak olasıdır.

## MCP Protokolündeki Mevcut Güvenlik Önlemleri ve Değerlendirmesi

Anthropic (soruda bahsedilen adıyla *Antopic*), MCP protokolünü tasarlarken bazı temel güvenlik önlemlerini dahil etmiştir. Bunların başında, protokolün **kimlik doğrulama ve yetkilendirme mekanizması** gelir. MCP, uzak sunucular için OAuth 2.0 tabanlı erişim token’ları kullanılmasını önererek, her istemci-sunucu bağlantısının bir yetki kontrolüne tabi olmasını sağlamaya çalışır. Bu sayede, her MCP sunucusu eylemini bir kullanıcı veya uygulama adına gerçekleştirecekse, önceden alınmış bir erişim iznine sahip olması beklenir. Ancak burada önemli bir nokta, mevcut spesifikasyondaki OAuth kullanım detaylarının her senaryoya uymayabileceğinin ortaya çıkmış olmasıdır. Topluluktan gelen geri bildirimlere göre MCP’nin ilk yetkilendirme tanımı, kurumsal ortamlardaki bazı modern uygulamalarla çelişmektedir ve bu konuda resmi spesifikasyonun güncellenmesi gündemdedir. Bu durum, protokolün yetkilendirme boyutunda henüz tam olgunlaşmadığını ve geliştirilmeye açık yanlar olduğunu göstermektedir.

Bir diğer yerleşik güvenlik önlemi, **iletişimin şifrelenmesi** ile ilgilidir. Her ne kadar MCP doğrudan “şifreleme zorunluluğu”nu kendi içinde dayatmasa da (zira bu genellikle taşıma katmanının sorumluluğudur), dokümantasyon ve topluluk rehberlerinde uzak bağlantılar için TLS destekli HTTPS kullanılmasının altı çizilir. Özellikle GitHub gibi MCP kullanan platformlar, kendi sunucuları ile istemci arasındaki etkileşimlerde güvenlik için ek mekanizmalar uygulamıştır. Örneğin GitHub’ın MCP sunucusu (Copilot ile entegrasyon amaçlı), paylaşılan depo verilerinde gizli anahtarların açığa çıkmasını önlemek için “push protection” adlı bir güvenlik filtresi kullanır; bu filtre sayesinde MCP üzerinden gerçekleştirilen eylemlerde hassas verilerin sızması engellenir. Bu tür önlemler MCP protokolünün parçası olmasa da, onu kullanan hizmetlerin kendi güvenlik katmanlarını eklediğini göstermektedir.

Anthropic’in MCP için geliştirdiği referans sunucularda da bazı güvenlik düşünceleri mevcuttur. Örneğin, yerel dosya sistemi sunucusu belli bir dizin altında erişime izin vererek bir tür *sandbox* yaratmayı hedefler. Ancak yapılan bağımsız güvenlik analizleri, bu yaklaşımın kusursuz olmadığını ortaya koymuştur. Bazı güvenlik araştırmaları, resmi dosya sistemi MCP sunucusunda dizin atlama veya sembolik bağ (symlink) yoluyla kısıtlamaların atlatılabildiğini ve bunun sunucunun çalıştığı sistemde daha geniş erişimlere yol açabildiğini göstermiştir. Bu bulgular, Anthropic’in koyduğu güvenlik önlemlerinin (dizin kısıtlaması gibi) tek başına yeterli olmadığını göstermiştir. Özellikle LLM tabanlı araçların çoğunlukla geliştirici rahatlığı için yüksek ayrıcalıklarla (örn. kullanıcı oturumunda veya bazen yönetici haklarıyla) çalıştırıldığı düşünülürse, bu tip açıklar kötüye kullanıldığında **sistem bütünlüğünü ciddi şekilde tehlikeye atmaktadır**.

Bununla birlikte, olumlu tarafından bakıldığında Anthropic ve genel olarak MCP topluluğu güvenlik açıklarına oldukça hızlı reaksiyon vermektedir. Örneğin bazı projelerde bildirilmiş uzaktan kod çalıştırma açıkları, proje geliştiricileri tarafından kısa sürede yamanmıştır. Aynı şekilde çeşitli sandbox kaçışı sorunlarına karşı da ilgili yamalar ve kullanıcılara yönelik uyarılar yayınlanmıştır. Bu durum, MCP ekosisteminin güvenlik konusunu ciddiye aldığını ve proaktif iyileştirmelere gittiğini göstermektedir. Yine de, henüz genç sayılabilecek bu protokol için mevcut güvenlik önlemlerinin *“yeterli”* olduğunu söylemek zordur. Ortaya çıkan her yeni kullanım senaryosu veya sunucu uygulaması, kendine özgü güvenlik açıkları barındırabilir. Anthropic’in başlangıçta protokole dahil ettiği temel güvenlik kavramları (OAuth ile yetkilendirme, JSON-RPC ile yapılandırılmış ileti vb.) önemli bir zemin sağlasa da, gerçek dünyadaki saldırı senaryoları bu önlemlerin etrafından dolaşmanın yollarını bulmuştur. Özetle, **MCP’nin güvenliği hala evrim geçirmektedir**; mevcut önlemler bazı tehditleri azaltmakla birlikte, protokolün tam anlamıyla güvenli kabul edilebilmesi için sürekli gözden geçirme, test etme ve güncelleme gerekmektedir.

## Geliştiriciler ve Kurumlar İçin Güvenli MCP Uygulama Önerileri

MCP protokolünü güvenli bir biçimde uygulamak ve kullanmak isteyen geliştiriciler ile kurumlar, aşağıdaki önlemleri göz önünde bulundurmalıdır:

* **Güvenli İletişim ve Sertifika Doğrulaması:** Uzak MCP sunucularıyla haberleşirken daima HTTPS protokolü kullanın ve sunucu sertifikasının doğrulandığından emin olun. Şifrelenmemiş HTTP üzerinden asla hassas veri iletmeyin; aksi halde MITM saldırılarına açık hale gelirsiniz. Gerekirse istemci tarafında, sunucu URL’sinin `https://` ile başlamadığını fark edince bağlantıyı reddeden kontroller ekleyin.
* **Güçlü Kimlik Doğrulama ve Yetkilendirme:** MCP sunucularına erişim için mümkünse OAuth 2.0 gibi ispatlanmış yöntemlerle alınan erişim token’ları kullanın. Her sunucunun erişim token’ına sadece gerekli asgari yetkileri (scopeları) tanıyın (örneğin bir dosya sistemi sunucusuna salt okunur erişim izni vermek gibi). “En az ayrıcalık” ilkesini gözetin; bir MCP sunucusunun kullanıcı adına yapabileceği işlemleri kısıtlayın. Ayrıca, bir istemci bir sunucuya erişirken tek oturumluk veya kısa ömürlü token’lar kullanmayı, bunları düzenli olarak yenilemeyi ihmal etmeyin.
* **Güvenilmeyen Sunuculara Karşı Tedbir:** Yalnızca güvendiğiniz kaynaklardan gelen MCP sunucularını yükleyin veya bağlanın. Topluluk tarafından pek incelenmemiş, rastgele depolardan gelen sunucu uygulamalarını kullanmak risklidir. Kurum içinde MCP kullanılacaksa, **onaylı bir sunucu listesi** oluşturarak kullanıcıların sadece bu sunuculara bağlanmasına izin verin. MCP istemci uygulamanız, bağlanılan sunucunun kimliğini (örneğin dijital imza veya hash doğrulaması ile) kontrol edebiliyorsa bu özelliği etkinleştirin.
* **Kod Bütünlüğü ve Güncellemeler:** MCP sunucu ve istemci yazılımlarınızın bütünlüğünü ve güncelliğini koruyun. Kendi geliştirdiğiniz MCP sunucularını dijital olarak imzalayın ve kullanıcıların indirdiği kodun bu imzayla eşleştiğini doğrulayın. Kullandığınız MCP bileşenlerinde çıkan güvenlik güncellemelerini yakından takip edin ve gecikmeden uygulayın. Standart bir **zafiyet yönetimi** süreci dahilinde, MCP ile ilgili kütüphaneleri ve araçları belirli aralıklarla tarayıp bilinen açıklar için yamaları geçirin.
* **Güvenli Kod Geliştirme Prensipleri:** Bir MCP sunucusu geliştiriyorsanız, kullanıcılardan veya LLM’den alacağınız her girdiğin potansiyel olarak zararlı olabileceğini varsayın. Özellikle komut satırı çağrıları, dosya erişimleri gibi işlemleri gerçekleştirirken girdi validasyonuna önem verin. Parametreleri sistem komutlarına iletmeden önce boşluk, noktalı virgül, ampersand gibi komut ayrıştırıcı karakterlerden arındırın veya bu karakterlere izin vermeyin. SQL sorguları, kabuk komutları veya işletim sistemi API’leri çağrıları yapıyorsanız **enjeksiyon karşıtı** güvenlik kalıplarını uygulayın (örn. parametreli sorgular, sabit argüman listeleri vb.). Ayrıca, derleme ve CI süreçlerinize statik kod analizi araçları entegre ederek zayıflıkları daha kod yazım aşamasında yakalamaya çalışın.
* **Sandbox ve Ayırılmış Haklar:** Mümkün olan her durumda, MCP sunucularını izole bir ortama hapsedin. Örneğin bir dosya sistemi MCP sunucusu, sadece belli bir klasör altında okuma/yazma yapabilecek şekilde *chroot/jail* ortamında veya konteyner içinde çalıştırılmalıdır. İşletim sistemi seviyesinde bu sunuculara ayrı kullanıcı hesapları tahsis etmek ve bu hesaplara minimum yetkileri vermek etkili bir yöntemdir. Böylece, olası bir saldırıda sunucunun yapabilecekleri kısıtlanmış olacaktır ve sistem geneline yayılması engellenir.
* **Kullanıcı Onayı ve Denetim Mekanizmaları:** MCP istemcisi tarafında, LLM’nin tetiklediği yüksek riskli eylemler için mutlaka kullanıcının onayını alacak bir adım ekleyin. Örneğin, dosya silme, yeni kullanıcı oluşturma, para transferi gibi kritik bir işlem bir araç ile yapılacaksa, LLM bunu istese dahi kullanıcıdan “Onaylıyor musunuz?” şeklinde bir geri bildirim almadan yürütmeyin. Bu, olası prompt enjeksiyonu vakalarında istenmeyen sonuçları önlemek için son savunma hattıdır. Benzer şekilde, MCP istemciniz gerçekleştirilen işlemleri kullanıcıya özetleyebiliyorsa (görev tamamlandığında “Sunucu X şu işlemi gerçekleştirdi” gibi), bu şeffaflık kullanıcıyı güvende tutmaya yardımcı olacaktır.
* **Kayıt ve İzleme:** MCP sunucularının yaptığı işlemleri merkezi bir günlük (log) sistemine kaydetmesi veya en azından yerel olarak log tutması çok önemlidir. Böylece, geriye dönük bir inceleme gerektiğinde hangi komutların çalıştırıldığı, hangi kaynaklara erişildiği tespit edilebilir. Kurumlar, MCP aracılığıyla gerçekleştirilen bütün hareketleri SIEM gibi güvenlik izleme sistemlerine besleyerek anormal bir durum olup olmadığını denetleyebilirler. Örneğin, normalde bir araç günde birkaç kez çalışırken aniden yüzlerce kez çalışmaya başlamışsa, bu bir kompromize işareti olabilir ve loglar sayesinde görülebilir.
* **Sürüm Kilitleme ve Doğrulama:** Üçüncü parti MCP sunucularını uygulamanıza entegre ediyorsanız, belirli güvenilir bir sürüme kilitleyin ve bu sunucunun kodunda sonradan bir değişiklik olup olmadığını izleyin. Otomatik güncellemeler yerine manuel inceleme sonrası güncelleme yapma yaklaşımını benimseyin. Bu sayede, bir araç güncellendiğinde içine eklenmiş olası zararlı bir kod parçasını fark etme şansınız olur.

Yukarıdaki önlemler, MCP protokolünün getirdiği esneklik ve güç ile beraber gelen riskleri azaltmaya yöneliktir. Gerek bireysel geliştiriciler, gerekse MCP’yi altyapılarında kullanmayı planlayan kurumlar, **“güvenliği en baştan tasarlama”** ilkesini uygulamalıdır. Bu, protokolün kendi sağladığı güvenlik özellikleri kadar, kullanım ortamındaki operasyonel güvenlik tedbirlerini de içerir.

## Sonuç

“Antopic” (Anthropic) tarafından geliştirilen açık kaynak MCP protokolü, yapay zekâ uygulamalarının yeteneklerini artıran yenilikçi bir mimari ve standart getirmiştir. Bu çalışma kapsamında MCP’nin mimari yapısı ve işleyişi detaylı bir şekilde incelenmiş; protokolün LLM’lerle araçlar arasında nasıl bir **bağlamsal köprü** kurduğu ortaya konmuştur. Elde edilen bulgular, MCP’nin sağladığı faydalar kadar, göz ardı edilmemesi gereken güvenlik boyutunu da vurgulamaktadır. Özellikle protokolün açık kaynak doğası sayesinde henüz geliştirme aşamasındayken çeşitli güvenlik açıkları tespit edilmiş ve paylaşılmıştır. Bu sayede geliştiriciler ve kullanıcılar, protokolü üretim ortamlarına taşımadan önce riskleri görme ve önlem alma fırsatı yakalamıştır.

Yapılan değerlendirmeler göstermektedir ki MCP üzerindeki bazı güvenlik açıklarının **önceden belirlenmesi ve giderilmesi**, ileride yaşanabilecek ciddi ihlallerin önüne geçebilecektir. Bu raporda dile getirilen potansiyel saldırı vektörleri ve gerçek dünyada karşılaşılan zafiyetler, protokolün uygulanması esnasında nelere dikkat edilmesi gerektiğine dair somut bir farkındalık yaratır. Gerek Anthropic’in resmi iyileştirmeleri, gerekse bağımsız araştırmacıların bulguları ışığında, MCP’nin güvenlik mimarisi sürekli evrilmektedir. Dolayısıyla bu çalışma, hem MCP geliştiricilerine hem de protokolü kendi sistemlerinde kullanmayı düşünen kurumlara yönelik proaktif bir uyarı niteliğindedir.

Teknik literatüre katkı anlamında, MCP protokolünün mimarisi ve işlevselliğine dair derinlemesine bir bakış sunulmuştur. Bu, henüz yeni sayılabilecek bir standart hakkında derli toplu bir bilgi birikimi sağlaması açısından değerlidir. Ayrıca **açık kaynak protokollerin güvenliği** konusunda genel çıkarımlar yapma imkânı da doğmuştur: Şeffaflık ve kolektif katkı sayesinde güvenlik açıklarını hızla bulup düzeltmek mümkün olsa da, açık ekosistemde güvenin tesis edilmesi ve sürdürülmesi ayrı bir çaba gerektirmektedir. Sonuç olarak, MCP protokolü özelinde elde edilen deneyimler, benzer şekilde geliştirilen diğer açık kaynak projelerde de güvenlik odaklı yaklaşımın önemini pekiştirmektedir.

MCP protokolü doğru uygulandığında yapay zekâ dünyasında verimlilik ve yetenek artışı sağlayan bir araçtır; ancak güvenlik prensipleri ikinci plana atılmadan, “önce güvenlik” yaklaşımıyla ele alınmalıdır. Bu denge sağlandığında, MCP gibi protokoller inovasyon ile emniyeti bir arada götürebilecek, hem geliştiriciler hem de kullanıcılar için büyük kazanımlar sunacaktır.

## Kaynaklar (seçme)

* Anthropic — Model Context Protocol (MCP) GitHub projesi ve resmi belgeler
* GitHub Docs — Model Context Protocol (MCP) hakkında dokümantasyon
* Bağımsız güvenlik raporları ve analizler (örnek güvenlik araştırma raporları, CVE bildirileri, proje yamaları)
